import pandas as pd
from typing import List, Tuple

def dehorn_trend(data: List[Tuple[pd.Timestamp, bool]]) -> List[Tuple[pd.Timestamp, bool]]:
    """
    Restituisce solo le coppie in cui lo stato (True/False) cambia, 
    mantenendo l'ultima occorrenza di ogni sequenza identica.

    >>> data = [(pd.to_datetime('1.1.1989'), True), (pd.to_datetime('1.1.1990'), False), (pd.to_datetime('1.1.1995'), False)]
    >>> dehorn_trend(data)
    [(pd.Timestamp('1989-01-01 00:00:00'), True), (pd.Timestamp('1995-01-01 00:00:00'), False)]
    """
    if not data:
        return []

    result = []
    
    # Iteriamo sulla lista confrontando l'elemento corrente con il successivo
    for i in range(len(data)):
        current_state = data[i][1]
        
        # Se siamo all'ultimo elemento OPPURE lo stato successivo Ã¨ diverso
        if i == len(data) - 1 or data[i+1][1] != current_state:
            result.append(data[i])
            
    return result

# Esecuzione del test
if __name__ == "__main__":
    import doctest
    doctest.testmod()

# 1. Filtriamo il DataFrame per il rinoceronte specifico
# Assumiamo che la colonna dell'identificativo si chiami 'rhino_id' 
# e quella dello stato 'is_dehorned' (booleana)
rhino_data = df[df['rhino_id'] == 'MPGRBF-02-05'].copy()

# 2. Ordiniamo i dati per data (come richiesto dal presupposto dell'Ex 3)
rhino_data = rhino_data.sort_values('date')

# 3. Trasformiamo le colonne in una lista di tuple (data, stato)
# Usiamo zip per accoppiare i valori delle due colonne
rhino_list = list(zip(rhino_data['date'], rhino_data['is_dehorned']))

# 4. Applichiamo la funzione dehorn_trend
trend_result = dehorn_trend(rhino_list)

# 5. Visualizziamo il risultato
print(f"Trend dei cambiamenti per il rinoceronte MPGRBF-02-05:")
for date, state in trend_result:
    status_str = "Dehorned" if state else "Horned"
    print(f"- Data: {date.strftime('%Y-%m-%d')} | Stato: {status_str}")
